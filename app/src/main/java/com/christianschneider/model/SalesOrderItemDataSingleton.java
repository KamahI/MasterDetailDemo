package com.christianschneider.model;

import android.content.Context;
import android.util.Log;

import com.christianschneider.masterdetaildemo.R;
import com.christianschneider.services.ODataOnlineManager;
import com.christianschneider.services.ODataOpenListener;
import com.christianschneider.services.OnlineODataStoreException;
import com.sap.maf.tools.logon.core.LogonCoreException;
import com.sap.smp.client.odata.ODataEntity;
import com.sap.smp.client.odata.ODataEntitySet;
import com.sap.smp.client.odata.ODataPropMap;
import com.sap.smp.client.odata.ODataProperty;
import com.sap.smp.client.odata.online.OnlineODataStore;
import com.sap.smp.client.odata.store.ODataResponseSingle;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Singleton to hold all product data in the christianschneiderApp class. It is kept as a member of
 * the christianschneiderApp class as a global variable.
 */
public class SalesOrderItemDataSingleton
{
    private static final String TAG = "SalesOrderItem";
    private static SalesOrderItemDataSingleton instance;
    private static Context appContext;

    /** ODataOnlineManager */
    ODataOnlineManager odataOnlineManager;

    /** An array of SalesOrderItem items - used for the master (list) view.
     *  This is the same variable name and type as generated by the Android Studio template.
     */
    public static List<SalesOrderItem> ITEMS;

    /** A map of SalesOrderItem items, the key used is SalesOrderID, but can be changed.
     * This is the same variable name generated by the Android Studio template.
     */
    public static final Map<String, SalesOrderItem> ITEM_MAP = new HashMap<>();

    /** String Array for List (Master) view */
    public static String[] listItems;

    /**
     * Create the Singleton instance
     */
    public static void createInstance(ODataOnlineManager odataOnlineManager)
    {
        if (instance == null) {
            // Create the instance
            instance = new SalesOrderItemDataSingleton(odataOnlineManager);
        }
    }

    /**
     * Initialize the Singleton with data from the OData service
     */
    public static void initialize(ODataOpenListener openListener, SalesOrder salesOrder) throws LogonCoreException {
        getTheData(openListener, salesOrder);
    }

    /**
     * Helper method to retrieve the data from the OData Response and
     * store it in the ODataTestActivity productList variable.
     */
    private static void getTheData(ODataOpenListener openListener, SalesOrder salesOrder)
    {
        try
        {
            ITEMS = getSalesOrderItems(openListener, salesOrder);
        }
        catch (OnlineODataStoreException e)
        {
            Log.e(TAG, "caught OnlineODataStoreException");
        }
    }

    /**
     * Create String Array for master (List) view and store the SalesOrder objects in a HashMap
     */
    private static void storeData()
    {
        listItems = new String[ITEMS.size()];
        int i = 0;

        for (SalesOrderItem element : ITEMS)
        {
            //Store SalesOrderItem objects in a HashMap
            ITEM_MAP.put(element.getNote(), element);

            //Store SalesOrderID in a String array
            listItems[i] = element.getNote();
            i++;
        }
        //logItems();
        Log.i(TAG, String.format("Stored %d items in HashMap", i));

    }


    /**
     * Method to request and extract the data from the OData response and create and Array of SalesOrder objects.
     * A do-while loop is used to loop until all entites have been received from the service.
     * In the for loop, the objects are created and the setter methods used to store the info
     * Once the list is complete, we add the SalesOrder objects to a Hashmap for rapid retrieval of
     * product details when showing the detail view.
     * The method returns an ArrayList of SalesOrder objects.
     * <p></p>
     * See notes in the source code on creating the OData Resource Path, and using the SDK
     * @return ArrayList of SalesOrder objects
     * @throws OnlineODataStoreException Thrown for errors in OData communication
     * @see SalesOrder
     */
    private static ArrayList<SalesOrderItem> getSalesOrderItems(ODataOpenListener openListener, SalesOrder salesOrder) throws OnlineODataStoreException
    {
        ArrayList<SalesOrderItem> pList = new ArrayList<>();

        //Get the open online store
        OnlineODataStore store = openListener.getStore();

        if (store!=null)
        {
            SalesOrderItem salesOrderItem;
            ODataProperty property;
            ODataPropMap properties;
            String resourcePath;

            try
            {
                /**
                 * Build the initial OData resource path and query options string from:
                 *  Collection ID: EntitySet Name
                 *  ?$orderby=   : query option that specifies the order (sorting) of the response
                 *  SalesOrderID    : sort key for the orderby directive
                 *
                 *  Instead of SalesOrderID, you can specify Collections.NOTE to have all SalesOrderSet
                 *  returned alphabetically (and by default displayed that way in the list view).
                 *
                 *  The christianschneider service enforces server-side paging and will return 20 entities per
                 *  request. To view the paging size ("$skiptoken=") value, paste the first URL below into a
                 *  browser window, and scroll to the bottom of the response. You do not have to
                 *  track the number of entities received in your code. The SDK will create the
                 *  next resource path string for you (as seen in the code below). When the returned
                 *  string is `null' you have received all entities.
                 *
                 *  Since there are 77 entities in the OData service we are calling, the do-while loop
                 *  will end up issuing the four requests below to receive all the data (20 entities at a time).
                 *   - http://192.168.0.76:8080/Workorder/SalesOrderSet?$orderby=SalesOrderID
                 *   - http://192.168.0.76:8080/Workorder/SalesOrderSet?$orderby=SalesOrderID&$skiptoken=20,20
                 *   - http://192.168.0.76:8080/Workorder/SalesOrderSet?$orderby=SalesOrderID&$skiptoken=40,40
                 *   - http://192.168.0.76:8080/Workorder/SalesOrderSet?$orderby=SalesOrderID&$skiptoken=60,60
                 */

                // Build initial resource path and query options string
                resourcePath = Collections.SALES_ORDER_SET + "('" + salesOrder.getSalesOrderId() + "')" + "/ToLineItems" + "?$orderby=" + Collections.ITEM_POSITION;
                // Loop until resourcePath is null
                Log.d("resourcePath", resourcePath);
                do
                {
                    Log.d(TAG, "Requesting: " + resourcePath);

                    //Executor method for reading an Entity set
                    ODataResponseSingle resp = store.executeReadEntitySet(resourcePath, null);

                    //Get the response payload
                    ODataEntitySet feed = (ODataEntitySet) resp.getPayload();

                    //Get the list of ODataEntity
                    List<ODataEntity> entities = feed.getEntities();

                    //Loop to retrieve the information from the response and store in the SalesOrderItem Object
                    for (ODataEntity entity : entities)
                    {
                        properties = entity.getProperties();
                        property = properties.get(Collections.NOTE);
                        salesOrderItem = new SalesOrderItem(property.getValue().toString());
                        salesOrderItem.setSalesOrderId(salesOrder.getSalesOrderId());
                        property = properties.get(Collections.PRODUCT_ID);
                        salesOrderItem.setProductID(property.getValue().toString());
                        property = properties.get(Collections.ITEM_POSITION);
                        salesOrderItem.setItemPosition(property.getValue().toString());
                        property = properties.get(Collections.NOTE_LANGUAGE);
                        salesOrderItem.setNoteLanguage(property.getValue().toString());
                        property = properties.get(Collections.CURRENCY_CODE);
                        salesOrderItem.setCurrencyCode(property.getValue().toString());
                        property = properties.get(Collections.CURRENCY_CODE);
                        salesOrderItem.setCurrencyCode(property.getValue().toString());
                        property = properties.get(Collections.DELIVERY_DATE);
                        salesOrderItem.setDeliveryDate(property.getValue().toString());
                        property = properties.get(Collections.QUANTATY);
                        salesOrderItem.setQuantity(property.getValue().toString());
                        property = properties.get(Collections.QUANTITY_UNIT);
                        salesOrderItem.setQuantityUnit(property.getValue().toString());

                        /**
                         * The unit price value from the christianschneider OData service has
                         * four decimal places, we'll round to two decimal places before storing the data
                         */
                        property = properties.get(Collections.GROSS_AMOUNT);
                        Float price = Float.valueOf(property.getValue().toString());
                        salesOrderItem.setGrossAmount(String.format("%.2f", price));

                        property = properties.get(Collections.NET_AMOUNT);
                        price = Float.valueOf(property.getValue().toString());
                        salesOrderItem.setNetAmount(String.format("%.2f", price));

                        property = properties.get(Collections.TAX_AMOUNT);
                        price = Float.valueOf(property.getValue().toString());
                        salesOrderItem.setTaxAmount(String.format("%.2f", price));

                        // Add this entity to the array
                        pList.add(salesOrderItem);

                    }

                    // Get the next resource path from the OData SDK. The call to getNextResourcePath()
                    // will return the appropriate string based on the server's skiptoken value.
                    resourcePath = feed.getNextResourcePath();

                }
                // Short circuit evaluation of the string to see if we should loop again.
                // When all entities have been received, resourcePath will be null
                while (resourcePath != null && !resourcePath.isEmpty());

                SalesOrderItem.logSalesOrderItemArrayList(pList);

                // Save a reference to the list in ITEMS.
                ITEMS = pList;

                // Store all items in ITEMS (ArrayList) in ITEM_MAP (HashMap) for rapid retrieval
                storeData();

            }
            catch (Exception e)
            {
                Log.e(TAG, appContext.getString(R.string.online_odata_store_exception));
                throw new OnlineODataStoreException(e);
            }
        }
        else
            Log.e(TAG, "Store not open");

        return pList;
    }

    /**
     * Returns an instance of the SalesOrderDataSingleton
     * @return Instance
     */
    public static SalesOrderItemDataSingleton getInstance()
    {
        // Return the instance
        return instance;
    }

    /**
     * Private constructor (Singleton)
     */
    private SalesOrderItemDataSingleton(ODataOnlineManager odataOnlineManager)
    {
        // Constructor hidden because this is a singleton
    }


}
