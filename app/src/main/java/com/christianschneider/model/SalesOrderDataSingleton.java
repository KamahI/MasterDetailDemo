package com.christianschneider.model;

import android.annotation.SuppressLint;
import android.content.Context;
import android.util.Log;

import com.christianschneider.masterdetaildemo.R;
import com.christianschneider.services.ODataOnlineManager;
import com.christianschneider.services.ODataOpenListener;
import com.christianschneider.services.OnlineODataStoreException;
import com.sap.maf.tools.logon.core.LogonCoreException;
import com.sap.smp.client.odata.ODataEntity;
import com.sap.smp.client.odata.ODataEntitySet;
import com.sap.smp.client.odata.ODataPropMap;
import com.sap.smp.client.odata.ODataProperty;
import com.sap.smp.client.odata.online.OnlineODataStore;
import com.sap.smp.client.odata.store.ODataResponseSingle;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Singleton to hold all product data in the christianschneiderApp class. It is kept as a member of
 * the christianschneiderApp class as a global variable.
 */
public class SalesOrderDataSingleton {
    private static final String TAG = "SalesOrderDataSingleton";
    private static SalesOrderDataSingleton instance;
    private static Context appContext;
    private static int skipValue = 0;
    private static ArrayList<SalesOrder> pList = new ArrayList<>();

    /**
     * ODataOnlineManager
     */
    ODataOnlineManager odataOnlineManager = new ODataOnlineManager();

    /**
     * An array of SalesOrder items - used for the master (list) view.
     * This is the same variable name and type as generated by the Android Studio template.
     */
    public static List<SalesOrder> ITEMS;

    /**
     * A map of SalesOrder items, the key used is SalesOrderID, but can be changed.
     * This is the same variable name generated by the Android Studio template.
     */
    public static final Map<String, SalesOrder> SALES_ORDER_MAP = new HashMap<>();

    /**
     * String Array for List (Master) view
     */
    public static String[] listItems;

    /**
     * Create the Singleton instance
     */
    public static void createInstance() {
        if (instance == null) {
            // Create the instance
            instance = new SalesOrderDataSingleton();
        }
    }

    /**
     * Initialize the Singleton with data from the OData service
     *
     * @param context App context
     */
    public static void initialize(Context context) throws LogonCoreException {
        appContext = context;
        try {
            createOnlineManager(context);
        } catch (LogonCoreException e) {
            e.printStackTrace();
        }
        getTheData();
    }

    /**
     * Method to create the ODataOnlineManager
     *
     * @param context App context
     * @see ODataOnlineManager
     */
    private static void createOnlineManager(Context context) throws LogonCoreException {
        try {
            ODataOnlineManager.openOnlineStore(context);

        } catch (OnlineODataStoreException e) {
            e.printStackTrace();
            Log.e(TAG, context.getString(R.string.unable_to_open_store));
        }

    }

    /**
     * Helper method to retrieve the data from the OData Response and
     * store it in the ODataTestActivity productList variable.
     */
    private static void getTheData() {
        try {
            ITEMS = getSalesOrderSets();
        } catch (OnlineODataStoreException e) {
            Log.e(TAG, "caught OnlineODataStoreException");
        }
    }

    /**
     * Create String Array for master (List) view and store the SalesOrder objects in a HashMap
     */
    private static void storeData() {
        listItems = new String[ITEMS.size()];
        int i = 0;

        for (SalesOrder element : ITEMS) {
            //Store SalesOrder objects in a HashMap
            SALES_ORDER_MAP.put(element.getSalesOrderId(), element);

            //Store SalesOrderID in a String array
            listItems[i] = element.getSalesOrderId();
            i++;
        }
        //logItems();
        Log.i(TAG, String.format("Stored %d items in HashMap", i));

    }


    /**
     * Method to request and extract the data from the OData response and create and Array of SalesOrder objects.
     * A do-while loop is used to loop until all entites have been received from the service.
     * In the for loop, the objects are created and the setter methods used to store the info
     * Once the list is complete, we add the SalesOrder objects to a Hashmap for rapid retrieval of
     * product details when showing the detail view.
     * The method returns an ArrayList of SalesOrder objects.
     * <p></p>
     * See notes in the source code on creating the OData Resource Path, and using the SDK
     *
     * @return ArrayList of SalesOrder objects
     * @throws OnlineODataStoreException Thrown for errors in OData communication
     * @see SalesOrder
     */
    @SuppressLint("LongLogTag")
    public static ArrayList<SalesOrder> getSalesOrderSets() throws OnlineODataStoreException {


        //Get the open online store
        ODataOpenListener openListener = ODataOpenListener.getInstance();
        OnlineODataStore store = openListener.getStore();

        if (store != null) {
            SalesOrder salesOrder;
            ODataProperty property;
            ODataPropMap properties;
            String resourcePath;

            try {
                /**
                 * Build the initial OData resource path and query options string from:
                 *  Collection ID: EntitySet Name
                 *  ?$orderby=   : query option that specifies the order (sorting) of the response
                 *  SalesOrderID    : sort key for the orderby directive
                 *
                 *  Instead of SalesOrderID, you can specify Collections.NOTE to have all SalesOrderSet
                 *  returned alphabetically (and by default displayed that way in the list view).
                 *
                 *  The christianschneider service enforces server-side paging and will return 20 entities per
                 *  request. To view the paging size ("$skiptoken=") value, paste the first URL below into a
                 *  browser window, and scroll to the bottom of the response. You do not have to
                 *  track the number of entities received in your code. The SDK will create the
                 *  next resource path string for you (as seen in the code below). When the returned
                 *  string is `null' you have received all entities.
                 *
                 *  Since there are 77 entities in the OData service we are calling, the do-while loop
                 *  will end up issuing the four requests below to receive all the data (20 entities at a time).
                 *   - http://192.168.0.76:8080/Workorder/SalesOrderSet?$orderby=SalesOrderID
                 *   - http://192.168.0.76:8080/Workorder/SalesOrderSet?$orderby=SalesOrderID&$skiptoken=20,20
                 *   - http://192.168.0.76:8080/Workorder/SalesOrderSet?$orderby=SalesOrderID&$skiptoken=40,40
                 *   - http://192.168.0.76:8080/Workorder/SalesOrderSet?$orderby=SalesOrderID&$skiptoken=60,60
                 */

                // Build initial resource path and query options string
                resourcePath = Collections.SALES_ORDER_SET + "?$top=5&$skip=" + skipValue + "&$orderby=" + Collections.SALES_ORDER_ID;
                // Loop until resourcePath is null
                Log.d("resourcePath", resourcePath);
//                do
//                {
                Log.d(TAG, "Requesting: " + resourcePath);

                //Executor method for reading an Entity set
                ODataResponseSingle resp = store.executeReadEntitySet(resourcePath, null);

                //Get the response payload
                ODataEntitySet feed = (ODataEntitySet) resp.getPayload();

                //Get the list of ODataEntity
                List<ODataEntity> entities = feed.getEntities();


                //Loop to retrieve the information from the response and store in the SalesOrder Object
                for (ODataEntity entity : entities) {
                    properties = entity.getProperties();
                    property = properties.get(com.christianschneider.model.Collections.SALES_ORDER_ID);
                    salesOrder = new SalesOrder(property.getValue().toString());
                    property = properties.get(Collections.NOTE);
                    salesOrder.setNote(property.getValue().toString());
                    property = properties.get(Collections.NOTE_LANGUAGE);
                    salesOrder.setNoteLanguage(property.getValue().toString());
                    property = properties.get(Collections.CUSTOMER_ID);
                    salesOrder.setCustomerId(property.getValue().toString());
                    property = properties.get(Collections.CUSTOMER_NAME);
                    salesOrder.setCustomerName(property.getValue().toString());
                    property = properties.get(Collections.CURRENCY_CODE);
                    salesOrder.setCurrencyCode(property.getValue().toString());
                    property = properties.get(Collections.LIFECYCLE_STATUS);
                    salesOrder.setLifecycleStatus(property.getValue().toString());
                    property = properties.get(Collections.LIFECYCLE_STATUS_DESCRIPTION);
                    salesOrder.setLifecycleStatusDescription(property.getValue().toString());
                    property = properties.get(Collections.BILLING_STATUS);
                    salesOrder.setBillingStatus(property.getValue().toString());
                    property = properties.get(Collections.BILLING_STATUS_DESCRIPTION);
                    salesOrder.setBillingStatusDescription(property.getValue().toString());
                    property = properties.get(Collections.DELIVERY_STATUS);
                    salesOrder.setDeliveryStatus(property.getValue().toString());
                    property = properties.get(Collections.DELIVERY_STATUS_DESCRIPTION);
                    salesOrder.setDeliveryStatusDescription(property.getValue().toString());
                    property = properties.get(Collections.CREATED_AT);
                    salesOrder.setCreatedAt(property.getValue().toString());
                    property = properties.get(Collections.CHANGED_AT);
                    salesOrder.setChangedAt(property.getValue().toString());

                    /**
                     * The unit price value from the christianschneider OData service has
                     * four decimal places, we'll round to two decimal places before storing the data
                     */
                    property = properties.get(Collections.GROSS_AMOUNT);
                    Float price = Float.valueOf(property.getValue().toString());
                    salesOrder.setGrossAmount(String.format("%.2f", price));

                    property = properties.get(Collections.NET_AMOUNT);
                    price = Float.valueOf(property.getValue().toString());
                    salesOrder.setNetAmount(String.format("%.2f", price));

                    property = properties.get(Collections.TAX_AMOUNT);
                    price = Float.valueOf(property.getValue().toString());
                    salesOrder.setTaxAmount(String.format("%.2f", price));

                    // Add this entity to the array
                    pList.add(salesOrder);
                    SalesOrderItemDataSingleton.initialize(openListener, salesOrder);


                }

                // Get the next resource path from the OData SDK. The call to getNextResourcePath()
                // will return the appropriate string based on the server's skiptoken value.
                // resourcePath = feed.getNextResourcePath();

//                }
                // Short circuit evaluation of the string to see if we should loop again.
                // When all entities have been received, resourcePath will be null
//                while (resourcePath != null && !resourcePath.isEmpty());

                SalesOrder.logSalesOrderArrayList(pList);

                // Save a reference to the list in ITEMS.
                ITEMS = pList;

                // Store all items in ITEMS (ArrayList) in SALES_ORDER_MAP (HashMap) for rapid retrieval
                storeData();
                skipValue += 5;

            } catch (Exception e) {
                Log.e(TAG, appContext.getString(R.string.online_odata_store_exception));
                throw new OnlineODataStoreException(e);
            }
        } else
            Log.e(TAG, "Store not open");

        return pList;
    }

    /**
     * Returns an instance of the SalesOrderDataSingleton
     *
     * @return Instance
     */
    public static SalesOrderDataSingleton getInstance() {
        // Return the instance
        return instance;
    }

    /**
     * Private constructor (Singleton)
     */
    private SalesOrderDataSingleton() {
        // Constructor hidden because this is a singleton
    }


}
